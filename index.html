<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Travel Photo Map</title>
    <link rel="stylesheet" href="css/leaflet.css">
    <link rel="stylesheet" href="css/MarkerCluster.css">
    <link rel="stylesheet" href="css/MarkerCluster.Default.css">
    <link rel="stylesheet" href="css/Leaflet.Photo.css">
    <link rel="stylesheet" href="css/map.css">
</head>
<body>
    <div id="map"></div>

    <script src="js/leaflet.js"></script>
    <script src="js/leaflet.markercluster.js"></script>
    <script src="js/Leaflet.Photo.js"></script>
    <!-- <script src="js/ForceLayout.js"></script> -->
    <script>
        (function () {
            var map = L.map('map').setView([20, 0], 2);

            var osmAttr = '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors';
            var cartoAttr = osmAttr + ', &copy; <a href="https://carto.com/attributions">CARTO</a>';

            var streetMap = L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: osmAttr,
                maxZoom: 19
            });

            var humanitarian = L.tileLayer('https://{s}.tile.openstreetmap.fr/hot/{z}/{x}/{y}.png', {
                attribution: osmAttr + ', Tiles by <a href="https://www.hotosm.org/">HOT</a> hosted by <a href="https://openstreetmap.fr/">OSM France</a>',
                maxZoom: 19
            });

            var terrain = L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
                attribution: 'Map data: ' + osmAttr + ', <a href="http://viewfinderpanoramas.org">SRTM</a> | Map style: &copy; <a href="https://opentopomap.org">OpenTopoMap</a>',
                maxZoom: 17
            });

            var satellite = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community',
                maxZoom: 18
            });

            var esriStreet = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/tile/{z}/{y}/{x}', {
                attribution: 'Tiles &copy; Esri &mdash; Source: Esri, DeLorme, NAVTEQ, USGS, Intermap, iPC, NRCAN, Esri Japan, METI, TomTom',
                maxZoom: 18
            });

            var positron = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png', {
                attribution: cartoAttr,
                maxZoom: 20,
                subdomains: 'abcd'
            });

            var darkMatter = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png', {
                attribution: cartoAttr,
                maxZoom: 20,
                subdomains: 'abcd'
            });

            var voyager = L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}.png', {
                attribution: cartoAttr,
                maxZoom: 20,
                subdomains: 'abcd'
            });

            var usgsTopo = L.tileLayer('https://basemap.nationalmap.gov/arcgis/rest/services/USGSTopo/MapServer/tile/{z}/{y}/{x}', {
                attribution: 'Tiles courtesy of the <a href="https://usgs.gov/">U.S. Geological Survey</a>',
                maxZoom: 20
            });

            var usgsImagery = L.tileLayer('https://basemap.nationalmap.gov/arcgis/rest/services/USGSImageryOnly/MapServer/tile/{z}/{y}/{x}', {
                attribution: 'Tiles courtesy of the <a href="https://usgs.gov/">U.S. Geological Survey</a>',
                maxZoom: 20
            });

            humanitarian.addTo(map);

            var baseLayers = {
                'Street Map': streetMap,
                'Humanitarian': humanitarian,
                'Terrain': terrain,
                'Satellite (Esri)': satellite,
                'Esri Street': esriStreet,
                'CartoDB Positron': positron,
                'CartoDB Dark Matter': darkMatter,
                'CartoDB Voyager': voyager,
                'USGS Topo': usgsTopo,
                'USGS Imagery': usgsImagery
            };
            var currentBaseLayer = humanitarian;

            function buildPopupHTML(photo) {
                var html = '<div class="photo-popup">';
                if (photo.type === 'video') {
                    if (photo.web_url) {
                        html += '<iframe class="popup-video-iframe" src="' + photo.web_url + '" allow="autoplay; encrypted-media" allowfullscreen></iframe>';
                    } else {
                        html += '<video controls preload="metadata"><source src="' + photo.url + '"></video>';
                    }
                } else {
                    html += '<img src="' + photo.thumbnail + '" alt="' + (photo.caption || 'Photo') + '">';
                }
                if (photo.google_photos_url) {
                    html += '<a href="' + photo.google_photos_url + '" target="_blank" rel="noopener noreferrer" class="photo-link">View on Google Photos</a>';
                }
                html += '<div class="popup-info">';
                if (photo.caption) {
                    html += '<p class="popup-caption">' + photo.caption + '</p>';
                }
                if (photo.date) {
                    html += '<p class="popup-date">' + photo.date + '</p>';
                }
                if (photo.tags && photo.tags.length > 0) {
                    html += '<div class="popup-tags">';
                    for (var i = 0; i < photo.tags.length; i++) {
                        html += '<span class="popup-tag">' + photo.tags[i] + '</span>';
                    }
                    html += '</div>';
                }
                html += '</div></div>';
                return html;
            }

            function showEmptyState() {
                var el = document.createElement('div');
                el.className = 'empty-state';
                el.innerHTML = '<h2>No Photos Yet</h2><p>Add geotagged photos to the <code>photos/</code> folder<br>and run <code>python scripts/process_photos.py</code></p>';
                document.body.appendChild(el);
            }

            // Hoisted state for slider rebuilds
            var photoLayer = null;
            var favoritesLayer = null;
            var allPhotos = [];
            var filteredPhotos = [];
            var currentClusterRadius = 30;
            var currentIconSize = 90;
            var cityClusters = [];
            var photoIndex = {};

            // Favorites helpers (localStorage)
            function getFavorites() {
                try { return JSON.parse(localStorage.getItem('photomap_favorites') || '{}'); }
                catch (e) { return {}; }
            }
            function setFavorites(favs) {
                localStorage.setItem('photomap_favorites', JSON.stringify(favs));
            }
            function getFavKey(photo) {
                return photo.url + '|' + photo.lat + '|' + photo.lng;
            }
            function isFavorite(photo) {
                return !!getFavorites()[getFavKey(photo)];
            }
            function toggleFavorite(photo) {
                var favs = getFavorites();
                var key = getFavKey(photo);
                if (favs[key]) { delete favs[key]; } else { favs[key] = true; }
                setFavorites(favs);
            }

            var lightboxIndex = -1;
            var lightboxOverlay = null;
            var lbZoom = { scale: 1, translateX: 0, translateY: 0, isPanning: false, isPinching: false, _didDrag: false };

            function resetZoom() {
                lbZoom.scale = 1;
                lbZoom.translateX = 0;
                lbZoom.translateY = 0;
                lbZoom.isPanning = false;
                lbZoom.isPinching = false;
                lbZoom._didDrag = false;
                if (lightboxOverlay) {
                    var content = lightboxOverlay.querySelector('.lightbox-media img, .lightbox-media video');
                    if (content) {
                        content.style.transform = '';
                        content.style.transformOrigin = '';
                    }
                    var mc = lightboxOverlay.querySelector('.lightbox-media');
                    if (mc) mc.classList.remove('zoomed');
                    var zc = lightboxOverlay.querySelector('.lightbox-zoom-controls');
                    if (zc) zc.classList.remove('visible');
                }
            }

            function openLightbox(index) {
                if (filteredPhotos.length === 0) return;
                if (index < 0) index = 0;
                if (index >= filteredPhotos.length) index = filteredPhotos.length - 1;
                lightboxIndex = index;
                resetZoom();
                var photo = filteredPhotos[index];

                if (!lightboxOverlay) {
                    lightboxOverlay = document.createElement('div');
                    lightboxOverlay.className = 'lightbox-overlay';
                    lightboxOverlay.innerHTML =
                        '<button class="lightbox-close">&times;</button>' +
                        '<button class="lightbox-favorite">&#9734;</button>' +
                        '<button class="lightbox-nav lightbox-prev">&#8249;</button>' +
                        '<div class="lightbox-media"></div>' +
                        '<button class="lightbox-nav lightbox-next">&#8250;</button>' +
                        '<div class="lightbox-zoom-controls">' +
                            '<button class="zoom-btn zoom-out">&minus;</button>' +
                            '<span class="zoom-level">1x</span>' +
                            '<button class="zoom-btn zoom-in">+</button>' +
                        '</div>' +
                        '<div class="lightbox-info">' +
                            '<p class="lightbox-caption"></p>' +
                            '<p class="lightbox-date"></p>' +
                            '<div class="lightbox-tags"></div>' +
                            '<a class="lightbox-link" target="_blank" rel="noopener noreferrer">View on Google Photos</a>' +
                        '</div>';
                    document.body.appendChild(lightboxOverlay);

                    lightboxOverlay.querySelector('.lightbox-close').addEventListener('click', function (evt) {
                        evt.stopPropagation();
                        closeLightbox();
                    });
                    lightboxOverlay.querySelector('.lightbox-prev').addEventListener('click', function (evt) {
                        evt.stopPropagation();
                        openLightbox(lightboxIndex - 1);
                    });
                    lightboxOverlay.querySelector('.lightbox-next').addEventListener('click', function (evt) {
                        evt.stopPropagation();
                        openLightbox(lightboxIndex + 1);
                    });
                    lightboxOverlay.querySelector('.lightbox-favorite').addEventListener('click', function (evt) {
                        evt.stopPropagation();
                        if (lightboxIndex < 0 || lightboxIndex >= filteredPhotos.length) return;
                        var photo = filteredPhotos[lightboxIndex];
                        toggleFavorite(photo);
                        var btn = lightboxOverlay.querySelector('.lightbox-favorite');
                        var fav = isFavorite(photo);
                        btn.innerHTML = fav ? '&#9733;' : '&#9734;';
                        btn.classList.toggle('is-favorite', fav);
                        rebuildPhotoLayer();
                        buildPhotoIndex();
                    });
                    lightboxOverlay.addEventListener('click', function (evt) {
                        if (evt.target === lightboxOverlay && !lbZoom._didDrag) closeLightbox();
                        lbZoom._didDrag = false;
                    });

                    // ── Lightbox zoom/pan logic ──
                    var mediaEl = lightboxOverlay.querySelector('.lightbox-media');
                    var zoomControls = lightboxOverlay.querySelector('.lightbox-zoom-controls');
                    var zoomLevelEl = lightboxOverlay.querySelector('.zoom-level');

                    lbZoom._fadeTimer = null;
                    function showZoomControls() {
                        zoomControls.classList.add('visible');
                        if (lbZoom._fadeTimer) clearTimeout(lbZoom._fadeTimer);
                        lbZoom._fadeTimer = setTimeout(function () {
                            if (lbZoom.scale <= 1) zoomControls.classList.remove('visible');
                        }, 2000);
                    }

                    function applyTransform() {
                        var content = mediaEl.querySelector('img, video');
                        if (!content) return;
                        content.style.transform = 'translate(' + lbZoom.translateX + 'px, ' + lbZoom.translateY + 'px) scale(' + lbZoom.scale + ')';
                        content.style.transformOrigin = '0 0';
                        zoomLevelEl.textContent = lbZoom.scale.toFixed(1) + 'x';
                        mediaEl.classList.toggle('zoomed', lbZoom.scale > 1);
                        showZoomControls();
                    }

                    function zoomAt(newScale, clientX, clientY) {
                        var rect = mediaEl.getBoundingClientRect();
                        var mx = clientX - rect.left;
                        var my = clientY - rect.top;
                        var prevScale = lbZoom.scale;
                        newScale = Math.max(1, Math.min(5, newScale));
                        var ratio = newScale / prevScale;
                        lbZoom.translateX = mx - ratio * (mx - lbZoom.translateX);
                        lbZoom.translateY = my - ratio * (my - lbZoom.translateY);
                        lbZoom.scale = newScale;
                        if (lbZoom.scale <= 1) { lbZoom.translateX = 0; lbZoom.translateY = 0; lbZoom.scale = 1; }
                        applyTransform();
                    }

                    // Wheel zoom
                    mediaEl.addEventListener('wheel', function (evt) {
                        evt.preventDefault();
                        var factor = evt.deltaY < 0 ? 1.15 : 1 / 1.15;
                        zoomAt(lbZoom.scale * factor, evt.clientX, evt.clientY);
                    }, { passive: false });

                    // Double-click zoom toggle
                    mediaEl.addEventListener('dblclick', function (evt) {
                        evt.preventDefault();
                        evt.stopPropagation();
                        if (lbZoom.scale > 1.05) {
                            lbZoom.scale = 1; lbZoom.translateX = 0; lbZoom.translateY = 0;
                            applyTransform();
                        } else {
                            zoomAt(2.5, evt.clientX, evt.clientY);
                        }
                    });

                    // Mouse drag pan
                    var _dragStartX, _dragStartY, _dragTxStart, _dragTyStart;
                    mediaEl.addEventListener('mousedown', function (evt) {
                        if (lbZoom.scale <= 1 || evt.button !== 0) return;
                        evt.preventDefault();
                        lbZoom.isPanning = true;
                        _dragStartX = evt.clientX; _dragStartY = evt.clientY;
                        _dragTxStart = lbZoom.translateX; _dragTyStart = lbZoom.translateY;
                    });
                    document.addEventListener('mousemove', function (evt) {
                        if (!lbZoom.isPanning) return;
                        var dx = evt.clientX - _dragStartX;
                        var dy = evt.clientY - _dragStartY;
                        if (Math.abs(dx) > 3 || Math.abs(dy) > 3) lbZoom._didDrag = true;
                        lbZoom.translateX = _dragTxStart + dx;
                        lbZoom.translateY = _dragTyStart + dy;
                        applyTransform();
                    });
                    document.addEventListener('mouseup', function () {
                        lbZoom.isPanning = false;
                    });

                    // Touch pinch-to-zoom and pan
                    var _touchDist0, _touchScale0, _touchMid;
                    mediaEl.addEventListener('touchstart', function (evt) {
                        if (evt.touches.length === 2) {
                            evt.preventDefault();
                            lbZoom.isPinching = true;
                            var dx = evt.touches[0].clientX - evt.touches[1].clientX;
                            var dy = evt.touches[0].clientY - evt.touches[1].clientY;
                            _touchDist0 = Math.sqrt(dx * dx + dy * dy);
                            _touchScale0 = lbZoom.scale;
                            _touchMid = {
                                x: (evt.touches[0].clientX + evt.touches[1].clientX) / 2,
                                y: (evt.touches[0].clientY + evt.touches[1].clientY) / 2
                            };
                        } else if (evt.touches.length === 1 && lbZoom.scale > 1) {
                            lbZoom.isPanning = true;
                            _dragStartX = evt.touches[0].clientX;
                            _dragStartY = evt.touches[0].clientY;
                            _dragTxStart = lbZoom.translateX;
                            _dragTyStart = lbZoom.translateY;
                        }
                    }, { passive: false });
                    mediaEl.addEventListener('touchmove', function (evt) {
                        if (lbZoom.isPinching && evt.touches.length === 2) {
                            evt.preventDefault();
                            var dx = evt.touches[0].clientX - evt.touches[1].clientX;
                            var dy = evt.touches[0].clientY - evt.touches[1].clientY;
                            var dist = Math.sqrt(dx * dx + dy * dy);
                            var newScale = _touchScale0 * (dist / _touchDist0);
                            zoomAt(newScale, _touchMid.x, _touchMid.y);
                        } else if (lbZoom.isPanning && evt.touches.length === 1 && lbZoom.scale > 1) {
                            evt.preventDefault();
                            lbZoom.translateX = _dragTxStart + (evt.touches[0].clientX - _dragStartX);
                            lbZoom.translateY = _dragTyStart + (evt.touches[0].clientY - _dragStartY);
                            applyTransform();
                        }
                    }, { passive: false });
                    mediaEl.addEventListener('touchend', function () {
                        lbZoom.isPinching = false;
                        lbZoom.isPanning = false;
                    });

                    // Zoom button handlers
                    lightboxOverlay.querySelector('.zoom-in').addEventListener('click', function (evt) {
                        evt.stopPropagation();
                        var rect = mediaEl.getBoundingClientRect();
                        zoomAt(lbZoom.scale * 1.4, rect.left + rect.width / 2, rect.top + rect.height / 2);
                    });
                    lightboxOverlay.querySelector('.zoom-out').addEventListener('click', function (evt) {
                        evt.stopPropagation();
                        var rect = mediaEl.getBoundingClientRect();
                        zoomAt(lbZoom.scale / 1.4, rect.left + rect.width / 2, rect.top + rect.height / 2);
                    });
                }

                // Populate media
                var mediaContainer = lightboxOverlay.querySelector('.lightbox-media');
                if (photo.type === 'video') {
                    if (photo.web_url) {
                        mediaContainer.innerHTML = '<iframe class="lightbox-video-iframe" src="' + photo.web_url + '" allow="autoplay; encrypted-media" allowfullscreen></iframe>';
                    } else {
                        mediaContainer.innerHTML = '<video controls autoplay><source src="' + photo.url + '"></video>';
                    }
                } else {
                    // Progressive loading: show thumbnail immediately, swap to high-res when loaded
                    var img = document.createElement('img');
                    img.src = photo.thumbnail;
                    img.alt = photo.caption || 'Photo';
                    img.className = 'lightbox-img loading';
                    mediaContainer.innerHTML = '';
                    mediaContainer.appendChild(img);

                    if (photo.web_url) {
                        var hiRes = new Image();
                        hiRes.onload = function () {
                            if (img.parentNode) {
                                img.src = hiRes.src;
                                img.classList.remove('loading');
                            }
                        };
                        hiRes.onerror = function () {
                            img.classList.remove('loading');
                        };
                        hiRes.src = photo.web_url;
                    } else {
                        img.classList.remove('loading');
                    }
                }

                // Populate info
                var captionEl = lightboxOverlay.querySelector('.lightbox-caption');
                captionEl.textContent = photo.caption || '';
                captionEl.style.display = photo.caption ? '' : 'none';

                var dateEl = lightboxOverlay.querySelector('.lightbox-date');
                dateEl.textContent = photo.date || '';
                dateEl.style.display = photo.date ? '' : 'none';

                var tagsEl = lightboxOverlay.querySelector('.lightbox-tags');
                if (photo.tags && photo.tags.length > 0) {
                    var tagsHtml = '';
                    for (var t = 0; t < photo.tags.length; t++) {
                        tagsHtml += '<span class="lightbox-tag">' + photo.tags[t] + '</span>';
                    }
                    tagsEl.innerHTML = tagsHtml;
                    tagsEl.style.display = '';
                } else {
                    tagsEl.innerHTML = '';
                    tagsEl.style.display = 'none';
                }

                var linkEl = lightboxOverlay.querySelector('.lightbox-link');
                if (photo.google_photos_url) {
                    linkEl.href = photo.google_photos_url;
                    linkEl.style.display = '';
                } else {
                    linkEl.style.display = 'none';
                }

                // Arrow visibility
                lightboxOverlay.querySelector('.lightbox-prev').style.display = index <= 0 ? 'none' : '';
                lightboxOverlay.querySelector('.lightbox-next').style.display = index >= filteredPhotos.length - 1 ? 'none' : '';

                lightboxOverlay.style.display = 'flex';

                // Update favorite star state
                var favBtn = lightboxOverlay.querySelector('.lightbox-favorite');
                if (favBtn) {
                    var fav = isFavorite(photo);
                    favBtn.innerHTML = fav ? '&#9733;' : '&#9734;';
                    favBtn.classList.toggle('is-favorite', fav);
                }

                // Preload adjacent high-res images (fall back to thumbnail if no web_url)
                if (index > 0 && filteredPhotos[index - 1].type !== 'video') {
                    new Image().src = filteredPhotos[index - 1].web_url || filteredPhotos[index - 1].thumbnail;
                }
                if (index < filteredPhotos.length - 1 && filteredPhotos[index + 1].type !== 'video') {
                    new Image().src = filteredPhotos[index + 1].web_url || filteredPhotos[index + 1].thumbnail;
                }
            }

            function closeLightbox() {
                if (lightboxOverlay) lightboxOverlay.style.display = 'none';
                lightboxIndex = -1;
            }

            document.addEventListener('keydown', function (evt) {
                if (lightboxIndex < 0) return;
                if (evt.key === 'Escape') closeLightbox();
                else if (evt.key === 'ArrowLeft') openLightbox(lightboxIndex - 1);
                else if (evt.key === 'ArrowRight') openLightbox(lightboxIndex + 1);
            });

            function buildPhotoIndex() {
                photoIndex = {};
                for (var i = 0; i < filteredPhotos.length; i++) {
                    var p = filteredPhotos[i];
                    photoIndex[p.url + '|' + p.lat + '|' + p.lng] = i;
                }
            }

            function onPhotoClick(e) {
                var photo = e.layer.photo;
                var key = photo.url + '|' + photo.lat + '|' + photo.lng;
                var index = photoIndex.hasOwnProperty(key) ? photoIndex[key] : -1;
                if (index >= 0) {
                    openLightbox(index);
                }
            }

            function rebuildPhotoLayer(photos) {
                var data = photos || filteredPhotos;

                // Stop force layout before rebuilding
                if (typeof ForceLayout !== 'undefined') ForceLayout.stop();

                // Stamp _isFavorite on each photo and partition
                var favs = getFavorites();
                var regularPhotos = [];
                var favoritePhotos = [];
                for (var i = 0; i < data.length; i++) {
                    var key = getFavKey(data[i]);
                    data[i]._isFavorite = !!favs[key];
                    if (data[i]._isFavorite) {
                        favoritePhotos.push(data[i]);
                    } else {
                        regularPhotos.push(data[i]);
                    }
                }

                // Remove old favorites layer
                if (favoritesLayer) {
                    favoritesLayer.off('click', onPhotoClick);
                    map.removeLayer(favoritesLayer);
                    favoritesLayer = null;
                }

                // Rebuild clustered layer for regular photos
                if (photoLayer && currentClusterRadius === photoLayer._lastClusterRadius && currentIconSize === photoLayer._lastIconSize) {
                    photoLayer.clear();
                    photoLayer.add(regularPhotos);
                } else {
                    if (photoLayer) {
                        photoLayer.off('click', onPhotoClick);
                        map.removeLayer(photoLayer);
                    }
                    photoLayer = L.photo.cluster({
                        maxClusterRadius: currentClusterRadius,
                        spiderfyDistanceMultiplier: 2,
                        iconSize: [currentIconSize, currentIconSize]
                    });
                    photoLayer._lastClusterRadius = currentClusterRadius;
                    photoLayer._lastIconSize = currentIconSize;
                    photoLayer.on('click', onPhotoClick);
                    photoLayer.add(regularPhotos).addTo(map);
                }

                // Favorites: separate non-clustered layer (always visible, slightly larger)
                if (favoritePhotos.length > 0) {
                    var favSize = currentIconSize + 10;
                    favoritesLayer = L.photo(null, {
                        icon: { iconSize: [favSize, favSize] }
                    });
                    favoritesLayer.add(favoritePhotos);
                    favoritesLayer.on('click', onPhotoClick);
                    favoritesLayer.addTo(map);
                }
            }

            // Load annotations (graceful failure if missing)
            fetch('data/annotations.json')
                .then(function (response) {
                    if (!response.ok) return [];
                    return response.json();
                })
                .then(function (annotations) {
                    if (!annotations || annotations.length === 0) return;
                    for (var i = 0; i < annotations.length; i++) {
                        var ann = annotations[i];
                        var icon = L.divIcon({
                            className: 'annotation-marker',
                            html: '<span class="annotation-pin">&#128204;</span>',
                            iconSize: [28, 28],
                            iconAnchor: [14, 28]
                        });
                        var marker = L.marker([ann.lat, ann.lng], { icon: icon });
                        var popupHTML = '<div class="annotation-popup">';
                        if (ann.title) popupHTML += '<strong>' + ann.title + '</strong>';
                        if (ann.date) popupHTML += '<br><span class="annotation-date">' + ann.date + '</span>';
                        if (ann.text) popupHTML += '<p>' + ann.text + '</p>';
                        popupHTML += '</div>';
                        marker.bindPopup(popupHTML);
                        marker.addTo(map);
                    }
                })
                .catch(function () {
                    // annotations.json missing is fine
                });

            // Intercity travel route (drawn after trip segments load)
            var travelRouteLayer = null;

            function haversineKm(lat1, lng1, lat2, lng2) {
                var R = 6371;
                var dLat = (lat2 - lat1) * Math.PI / 180;
                var dLng = (lng2 - lng1) * Math.PI / 180;
                var a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                    Math.sin(dLng / 2) * Math.sin(dLng / 2);
                return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            }

            var tripSegments = [];

            function assignPhotosToTripSegments(photos, segments) {
                // Sort photos by datetime or date
                var sorted = photos.slice().sort(function (a, b) {
                    var aTime = a.datetime || a.date || '';
                    var bTime = b.datetime || b.date || '';
                    return aTime.localeCompare(bTime);
                });

                // Parse segment boundaries
                var parsedSegments = segments.map(function (seg, idx) {
                    return {
                        index: idx,
                        name: seg.name,
                        start: new Date(seg.start),
                        end: new Date(seg.end),
                        color: seg.color,
                        lat: seg.lat,
                        lng: seg.lng,
                        photos: []
                    };
                });

                // Assign each photo to a segment
                for (var i = 0; i < sorted.length; i++) {
                    var photo = sorted[i];
                    var photoTime = null;

                    // Try to parse datetime first, fall back to date
                    if (photo.datetime) {
                        photoTime = new Date(photo.datetime);
                    } else if (photo.date) {
                        // Date-only: assume noon for comparison
                        photoTime = new Date(photo.date + 'T12:00:00');
                    }

                    if (!photoTime || isNaN(photoTime.getTime())) {
                        // No valid time, skip assignment
                        photo.cityIndex = -1;
                        photo.cityName = 'Unknown';
                        photo.cityColor = '#999';
                        continue;
                    }

                    // Find matching segment
                    var matched = false;
                    for (var s = 0; s < parsedSegments.length; s++) {
                        var seg = parsedSegments[s];
                        if (photoTime >= seg.start && photoTime < seg.end) {
                            photo.cityIndex = s;
                            photo.cityName = seg.name;
                            photo.cityColor = seg.color;
                            seg.photos.push(photo);
                            matched = true;
                            break;
                        }
                    }

                    if (!matched) {
                        photo.cityIndex = -1;
                        photo.cityName = 'Unknown';
                        photo.cityColor = '#999';
                    }
                }

                // Build cluster-like structure for compatibility
                var clusters = parsedSegments.map(function (seg) {
                    var dates = seg.photos.map(function (p) { return p.date || ''; }).filter(function (d) { return d; }).sort();
                    return {
                        photos: seg.photos,
                        centroidLat: seg.lat,
                        centroidLng: seg.lng,
                        cityName: seg.name,
                        color: seg.color,
                        startDate: dates[0] || '',
                        endDate: dates[dates.length - 1] || ''
                    };
                });

                return clusters;
            }

            function formatDateShort(isoDate) {
                if (!isoDate) return '';
                var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                var parts = isoDate.split('-');
                if (parts.length < 3) return isoDate;
                return months[parseInt(parts[1], 10) - 1] + ' ' + parseInt(parts[2], 10);
            }

            // Load trip segments and manifest together
            Promise.all([
                fetch('data/trip_segments.json').then(function (r) { return r.ok ? r.json() : []; }),
                fetch('data/manifest.json').then(function (r) { if (!r.ok) throw new Error('Failed to load manifest'); return r.json(); })
            ])
                .then(function (results) {
                    tripSegments = results[0] || [];
                    var photos = results[1];

                    if (!photos || photos.length === 0) {
                        showEmptyState();
                        return;
                    }

                    allPhotos = photos;
                    cityClusters = assignPhotosToTripSegments(allPhotos, tripSegments);
                    filteredPhotos = allPhotos;
                    rebuildPhotoLayer();
                    buildPhotoIndex();

                    // Draw intercity travel route (two-layer polylines + arrows)
                    var arrowMarkers = [];
                    if (tripSegments.length > 1) {
                        var routeGroup = L.layerGroup();

                        function calcBearing(lat1, lng1, lat2, lng2) {
                            var dLng = (lng2 - lng1) * Math.PI / 180;
                            var lat1r = lat1 * Math.PI / 180;
                            var lat2r = lat2 * Math.PI / 180;
                            var y = Math.sin(dLng) * Math.cos(lat2r);
                            var x = Math.cos(lat1r) * Math.sin(lat2r) - Math.sin(lat1r) * Math.cos(lat2r) * Math.cos(dLng);
                            return (Math.atan2(y, x) * 180 / Math.PI + 360) % 360;
                        }

                        for (var ri = 0; ri < tripSegments.length - 1; ri++) {
                            var from = tripSegments[ri];
                            var to = tripSegments[ri + 1];
                            var coords = [[from.lat, from.lng], [to.lat, to.lng]];

                            // Background: solid, thick, subtle
                            var bgLine = L.polyline(coords, { color: from.color, weight: 5, opacity: 0.3, lineCap: 'round' });
                            bgLine.bindPopup(from.name + ' \u2192 ' + to.name);
                            routeGroup.addLayer(bgLine);

                            // Foreground: dashed, animated flow
                            var fgLine = L.polyline(coords, { color: from.color, weight: 3, opacity: 0.7, dashArray: '8, 12', className: 'route-line-animated' });
                            routeGroup.addLayer(fgLine);

                            // Arrow marker at midpoint
                            var midLat = (from.lat + to.lat) / 2;
                            var midLng = (from.lng + to.lng) / 2;
                            var bearing = calcBearing(from.lat, from.lng, to.lat, to.lng);
                            var arrowIcon = L.divIcon({
                                className: 'route-arrow-icon',
                                html: '<svg width="16" height="16" viewBox="0 0 16 16"><path d="M8 1 L14 13 L8 9 L2 13 Z" fill="' + from.color + '" opacity="0.85" transform="rotate(' + bearing + ', 8, 8)"/></svg>',
                                iconSize: [16, 16],
                                iconAnchor: [8, 8]
                            });
                            var arrowMk = L.marker([midLat, midLng], { icon: arrowIcon, interactive: false });
                            arrowMarkers.push(arrowMk);
                            routeGroup.addLayer(arrowMk);
                        }

                        travelRouteLayer = routeGroup;
                        routeGroup.addTo(map);
                    }

                    // Show/hide arrow markers based on zoom level
                    map.on('zoomend', function () {
                        var zoom = map.getZoom();
                        for (var ai = 0; ai < arrowMarkers.length; ai++) {
                            var el = arrowMarkers[ai].getElement ? arrowMarkers[ai].getElement() : null;
                            if (el) {
                                el.style.display = zoom < 4 ? 'none' : '';
                            }
                        }
                    });

                    // Build unique sorted dates
                    var dateSet = {};
                    for (var i = 0; i < allPhotos.length; i++) {
                        if (allPhotos[i].date) dateSet[allPhotos[i].date] = true;
                    }
                    var uniqueDates = Object.keys(dateSet).sort();

                    // Calculate week/month boundary markers
                    var monthNames = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
                    var boundaryMarkers = [];
                    for (var bi = 0; bi < uniqueDates.length; bi++) {
                        var bd = new Date(uniqueDates[bi] + 'T12:00:00');
                        if (bd.getDate() === 1) {
                            boundaryMarkers.push({ index: bi, type: 'month', label: monthNames[bd.getMonth()] });
                        } else if (bd.getDay() === 1) {
                            boundaryMarkers.push({ index: bi, type: 'week', label: '' });
                        }
                    }

                    // Build timeline segments directly from trip segments
                    // Map each date to a segment based on segment boundaries
                    var dateSegmentMap = {};
                    for (var di = 0; di < uniqueDates.length; di++) {
                        var dStr = uniqueDates[di];
                        var dateTime = new Date(dStr + 'T12:00:00'); // Use noon for date-only comparison
                        var bestSeg = -1;
                        for (var si = 0; si < tripSegments.length; si++) {
                            var segStart = new Date(tripSegments[si].start);
                            var segEnd = new Date(tripSegments[si].end);
                            if (dateTime >= segStart && dateTime < segEnd) {
                                bestSeg = si;
                                break;
                            }
                        }
                        dateSegmentMap[dStr] = bestSeg >= 0 ? bestSeg : 0;
                    }

                    // Build contiguous runs for timeline segments
                    var timelineSegments = [];
                    if (uniqueDates.length > 0) {
                        var runStart = 0;
                        var runSegment = dateSegmentMap[uniqueDates[0]];
                        for (var ri = 1; ri <= uniqueDates.length; ri++) {
                            var curSegment = ri < uniqueDates.length ? dateSegmentMap[uniqueDates[ri]] : -1;
                            if (curSegment !== runSegment) {
                                var seg = tripSegments[runSegment] || {};
                                timelineSegments.push({
                                    clusterIndex: runSegment,
                                    startIdx: runStart,
                                    count: ri - runStart,
                                    color: seg.color || '#999',
                                    cityName: seg.name || 'Unknown'
                                });
                                runStart = ri;
                                runSegment = curSegment;
                            }
                        }
                    }

                    // Build control panel (replaces UnifiedControl and L.control.layers)
                    function buildControlPanel() {
                        var totalDates = uniqueDates.length || 1;

                        // Build timeline track segments HTML (dot + conditional label + tooltip)
                        var segmentsHtml = '';
                        for (var s = 0; s < timelineSegments.length; s++) {
                            var seg = timelineSegments[s];
                            var leftPct = (seg.startIdx / totalDates * 100).toFixed(2);
                            var widthPct = (seg.count / totalDates * 100).toFixed(2);
                            var showInline = parseFloat(widthPct) >= 12 || s === 0 || s === timelineSegments.length - 1;
                            var labelPos = (s % 2 === 0) ? 'label-top' : 'label-bottom';
                            segmentsHtml += '<div class="timeline-segment ' + labelPos + '" data-city="' + seg.cityName + '" style="--seg-offset:' + leftPct + '%;--seg-size:' + widthPct + '%;background:' + seg.color + '">' +
                                '<span class="segment-dot"></span>' +
                                (showInline ? '<span class="segment-label-inline">' + seg.cityName + '</span>' : '') +
                                '<span class="segment-tooltip">' + seg.cityName + '</span></div>';
                        }

                        // Build boundary markers HTML
                        var boundaryHtml = '';
                        for (var bm = 0; bm < boundaryMarkers.length; bm++) {
                            var marker = boundaryMarkers[bm];
                            var pos = (marker.index / totalDates * 100).toFixed(2);
                            if (marker.type === 'month') {
                                boundaryHtml += '<div class="timeline-boundary timeline-boundary-month" style="--boundary-pos:' + pos + '%"><span class="boundary-label">' + marker.label + '</span></div>';
                            } else {
                                boundaryHtml += '<div class="timeline-boundary timeline-boundary-week" style="--boundary-pos:' + pos + '%"></div>';
                            }
                        }

                        var maxIdx = uniqueDates.length > 0 ? uniqueDates.length - 1 : 0;
                        var startLabel = uniqueDates.length > 0 ? formatDateShort(uniqueDates[0]) : '';
                        var endLabel = uniqueDates.length > 0 ? formatDateShort(uniqueDates[maxIdx]) : '';

                        // Build layer radio buttons HTML
                        var layerNames = Object.keys(baseLayers);
                        var layerHtml = '<div class="layer-group-title">Base Map</div>';
                        for (var li = 0; li < layerNames.length; li++) {
                            var checked = layerNames[li] === 'Humanitarian' ? ' checked' : '';
                            layerHtml += '<label class="layer-option"><input type="radio" name="base-layer" value="' + layerNames[li] + '"' + checked + '> ' + layerNames[li] + '</label>';
                        }
                        layerHtml += '<hr class="layer-separator">';
                        layerHtml += '<div class="layer-group-title">Overlays</div>';
                        layerHtml += '<label class="layer-option"><input type="checkbox" id="travel-route-toggle" checked> Travel Route</label>';

                        // Toggle button
                        var toggleBtn = document.createElement('button');
                        toggleBtn.className = 'panel-toggle open';
                        toggleBtn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round"><line x1="4" y1="6" x2="20" y2="6"/><line x1="4" y1="12" x2="20" y2="12"/><line x1="4" y1="18" x2="20" y2="18"/></svg>';
                        toggleBtn.style.display = 'none'; // hidden while panel is open
                        document.body.appendChild(toggleBtn);

                        // Panel
                        var panel = document.createElement('div');
                        panel.className = 'control-panel';
                        panel.innerHTML =
                            '<div class="panel-header"><h3>Controls</h3><button class="panel-close">&times;</button></div>' +
                            '<details class="panel-section" open>' +
                                '<summary>Timeline</summary>' +
                                '<div class="panel-section-content">' +
                                    '<div class="timeline-bar">' +
                                        '<div class="timeline-track">' + segmentsHtml + boundaryHtml + '<div class="timeline-range-fill" style="--range-start:0%;--range-size:100%"></div></div>' +
                                        '<input type="range" class="timeline-handle timeline-handle-min" min="0" max="' + maxIdx + '" value="0">' +
                                        '<input type="range" class="timeline-handle timeline-handle-max" min="0" max="' + maxIdx + '" value="' + maxIdx + '">' +
                                        '<div class="timeline-date-display">' +
                                            '<span class="timeline-date-start">' + startLabel + '</span>' +
                                            '<span class="timeline-date-end">' + endLabel + '</span>' +
                                        '</div>' +
                                        '<div class="timeline-photo-count"><span class="photo-count-number">' + allPhotos.length + '</span> / ' + allPhotos.length + ' photos</div>' +
                                    '</div>' +
                                '</div>' +
                            '</details>' +
                            '<details class="panel-section">' +
                                '<summary>Map Layers</summary>' +
                                '<div class="panel-section-content">' + layerHtml + '</div>' +
                            '</details>' +
                            '<details class="panel-section">' +
                                '<summary>Settings</summary>' +
                                '<div class="panel-section-content">' +
                                    '<label>Cluster Radius <span class="slider-value" id="cluster-val">' + currentClusterRadius + '</span></label>' +
                                    '<input type="range" id="cluster-slider" min="10" max="100" value="' + currentClusterRadius + '">' +
                                    '<label>Photo Size <span class="slider-value" id="size-val">' + currentIconSize + 'px</span></label>' +
                                    '<input type="range" id="size-slider" min="45" max="180" value="' + currentIconSize + '">' +
                                '</div>' +
                            '</details>';
                        document.body.appendChild(panel);

                        // Prevent map interaction when interacting with panel
                        L.DomEvent.disableClickPropagation(panel);
                        L.DomEvent.disableScrollPropagation(panel);
                        L.DomEvent.disableClickPropagation(toggleBtn);

                        // Toggle open/close
                        function togglePanel() {
                            var isHidden = panel.classList.toggle('hidden');
                            toggleBtn.classList.toggle('open', !isHidden);
                            toggleBtn.style.display = isHidden ? '' : 'none';
                        }
                        toggleBtn.addEventListener('click', togglePanel);
                        panel.querySelector('.panel-close').addEventListener('click', togglePanel);

                        // Wire base layer switching
                        var radios = panel.querySelectorAll('input[name="base-layer"]');
                        for (var r = 0; r < radios.length; r++) {
                            radios[r].addEventListener('change', function () {
                                map.removeLayer(currentBaseLayer);
                                currentBaseLayer = baseLayers[this.value];
                                currentBaseLayer.addTo(map);
                            });
                        }

                        // Wire travel route toggle
                        var routeToggle = panel.querySelector('#travel-route-toggle');
                        if (routeToggle) {
                            routeToggle.addEventListener('change', function () {
                                if (this.checked) {
                                    if (travelRouteLayer) travelRouteLayer.addTo(map);
                                } else {
                                    if (travelRouteLayer) map.removeLayer(travelRouteLayer);
                                }
                            });
                        }

                        // Mobile touch handler for segment tooltips
                        var segments = panel.querySelectorAll('.timeline-segment');
                        for (var ts = 0; ts < segments.length; ts++) {
                            segments[ts].addEventListener('touchstart', (function (allSegs) {
                                return function () {
                                    for (var c = 0; c < allSegs.length; c++) allSegs[c].classList.remove('touched');
                                    this.classList.add('touched');
                                };
                            })(segments));
                        }
                    }
                    buildControlPanel();

                    // Timeline slider handlers
                    var handleMin = document.querySelector('.timeline-handle-min');
                    var handleMax = document.querySelector('.timeline-handle-max');
                    var dateStartLabel = document.querySelector('.timeline-date-start');
                    var dateEndLabel = document.querySelector('.timeline-date-end');

                    var _filterTimeout = null;

                    function scheduleFilterUpdate() {
                        if (_filterTimeout) clearTimeout(_filterTimeout);
                        _filterTimeout = setTimeout(applyTimelineFilter, 150);
                    }

                    function updatePhotoCount(count) {
                        var el = document.querySelector('.timeline-photo-count');
                        if (el) {
                            el.innerHTML = '<span class="photo-count-number">' + count + '</span> / ' + allPhotos.length + ' photos';
                        }
                    }

                    // Cheap visual update on every input event
                    function onTimelineVisualUpdate() {
                        var minIdx = parseInt(handleMin.value, 10);
                        var maxIdx = parseInt(handleMax.value, 10);
                        if (minIdx > maxIdx) {
                            if (this === handleMin) { handleMin.value = maxIdx; minIdx = maxIdx; }
                            else { handleMax.value = minIdx; maxIdx = minIdx; }
                        }

                        dateStartLabel.textContent = formatDateShort(uniqueDates[minIdx]);
                        dateEndLabel.textContent = formatDateShort(uniqueDates[maxIdx]);

                        // Update range fill indicator
                        var totalDates = uniqueDates.length || 1;
                        var rangeFill = document.querySelector('.timeline-range-fill');
                        if (rangeFill) {
                            rangeFill.style.setProperty('--range-start', (minIdx / totalDates * 100) + '%');
                            rangeFill.style.setProperty('--range-size', ((maxIdx - minIdx + 1) / totalDates * 100) + '%');
                        }

                        // Quick photo count (no array allocation)
                        var minDate = uniqueDates[minIdx];
                        var maxDate = uniqueDates[maxIdx];
                        var count = 0;
                        for (var f = 0; f < allPhotos.length; f++) {
                            var pd = allPhotos[f].date || '';
                            if (pd >= minDate && pd <= maxDate) count++;
                        }
                        updatePhotoCount(count);

                        scheduleFilterUpdate();
                    }

                    // Expensive filter + rebuild (debounced at 150ms)
                    function applyTimelineFilter() {
                        var minIdx = parseInt(handleMin.value, 10);
                        var maxIdx = parseInt(handleMax.value, 10);
                        var minDate = uniqueDates[minIdx];
                        var maxDate = uniqueDates[maxIdx];

                        filteredPhotos = [];
                        for (var f = 0; f < allPhotos.length; f++) {
                            var pd = allPhotos[f].date || '';
                            if (pd >= minDate && pd <= maxDate) {
                                filteredPhotos.push(allPhotos[f]);
                            }
                        }

                        rebuildPhotoLayer();
                        buildPhotoIndex();
                    }

                    function onTimelineRelease() {
                        // Flush any pending debounced filter
                        if (_filterTimeout) {
                            clearTimeout(_filterTimeout);
                            _filterTimeout = null;
                            applyTimelineFilter();
                        }
                        try {
                            map.flyToBounds(photoLayer.getBounds(), { padding: [50, 50], duration: 0.8, maxZoom: 14 });
                        } catch (e) {}
                    }

                    if (handleMin && handleMax) {
                        handleMin.addEventListener('input', onTimelineVisualUpdate);
                        handleMax.addEventListener('input', onTimelineVisualUpdate);
                        handleMin.addEventListener('change', onTimelineRelease);
                        handleMax.addEventListener('change', onTimelineRelease);
                    }

                    // Settings slider handlers (debounced)
                    var _clusterTimeout = null;
                    var _sizeTimeout = null;

                    document.getElementById('cluster-slider').addEventListener('input', function () {
                        currentClusterRadius = parseInt(this.value, 10);
                        document.getElementById('cluster-val').textContent = currentClusterRadius;
                        if (_clusterTimeout) clearTimeout(_clusterTimeout);
                        _clusterTimeout = setTimeout(function () {
                            if (filteredPhotos.length > 0) rebuildPhotoLayer();
                        }, 100);
                    });

                    document.getElementById('size-slider').addEventListener('input', function () {
                        currentIconSize = parseInt(this.value, 10);
                        document.getElementById('size-val').textContent = currentIconSize + 'px';
                        if (_sizeTimeout) clearTimeout(_sizeTimeout);
                        _sizeTimeout = setTimeout(function () {
                            if (filteredPhotos.length > 0) rebuildPhotoLayer();
                        }, 100);
                    });

                    try {
                        map.fitBounds(photoLayer.getBounds(), { padding: [50, 50] });
                    } catch (e) {
                        // getBounds can fail if all markers are at the same point
                    }

                    // Force-directed layout: disabled for now
                    // var _forceDebounce = null;
                    // function scheduleForceLayout() {
                    //     if (_forceDebounce) clearTimeout(_forceDebounce);
                    //     _forceDebounce = setTimeout(function () {
                    //         if (photoLayer && !photoLayer._spiderfied) {
                    //             ForceLayout.run(map, photoLayer, currentIconSize);
                    //         }
                    //     }, 200);
                    // }
                    // photoLayer.on('animationend', function () {
                    //     setTimeout(scheduleForceLayout, 100);
                    // });
                    // map.on('moveend', scheduleForceLayout);
                })
                .catch(function (err) {
                    console.error('Error loading photo manifest:', err);
                    showEmptyState();
                });
        })();
    </script>
</body>
</html>
